//as we succeed SVBRDF, we can keep track of GRF !
//so, what we can do from scratch ? Maybe there are some ways ! Let's take my old or recent other repositories !
//Coming soon !
//At the moment, we can reject all formulas we saw in mathematics in our life and produce some things !
//I mean old approximate solutions until today ! I mean one complete approximate solution and only one !
//My nephew Edis Louis Rasulov succeeded to produce something for himself ! Let's ask him !
//Before that moment, I will search for nowadaays mathematical research areas and transform the statements
//to apply in physics ! Let's try an old colleague at CNRS-LIPN chao bau Ngo !
//I will look at extending the areas of his researches ! It seems that he doesn't share so much things.
//So, what is he hidding ? What am I hidding ? So I choose this totally absurd sentence :
//"Formes automorphes continues sur un espace vectorielle à 11 dimensions (matrix model) et
//series génératrices associées". I studied generative series at college. Sorry, this is totally stupid
//and from scratch but we can again create non weapon functions here ! Maybe it can help in other
//areas of researches !

//Let's try to start. Notice that I don't use transluciency and transparency !
void secureAutomorpheTransmissionCommands( ..... )
{
  //With BSDF, there is a way to use BTDF but in the past, nobody did it.
  //so, now have to express transmission with GRF. That means ...
  float h = ...... ; //sorry I used something from nuclearphysicsReality folder, but physically,
                    // this is possible to take a term that permit wide scale things with ....

  //here we enforce in infinitesimal formulas. That means that we deal with irradiance or radiance.
  //We saw it because we use another formula coming from nuclear physics. So, now, we will use common compositing for creating new passes
  //that secure graphics for rendering equation instead of using path tracing.
  ///and we will extract a texture later because h is not a data nor a spin nor fully nuclear subject !
  ....


  //to do secure graphics, h must fullfill derivatives for rendering equation that cancel shadow maps. Shadow maps can be used for rendering
  //equation of kajiya but here, we have to cancel it. So, it means more rays for shadows. This will be very accurate !
  //This behaviour is the same as seen in physic engines ! So, don't use Runge Kutta 4 method and use something
  //radiance*h*I <= L* addElectricalSupport. This comes from scratch (spintronics from scratch and electrical support can be approximated
  //to create an approximate textures). As spintronic contains h*I <= L* addElectricalSupport (from scratch)
  //it cancel radiance, then the raytracer doesn't have to wonder about any rays !

  //clamp radiance from super energy term to enhance hard edges (this is a pass - from scratch).
  float3 result = clamp( radiance, 0, superenergyTerm);             //neutrinos can have zero mass but this is not finished yet
  float3 result2 = clamp( result, addElectricalSupport(....), ...); //Let's take a formula taht can be cited in futur academic pdfs !
                                                                    //it is not obvious because techniques and formulas are heavily expressed 
                                                                    //interlinked. And the most common powerfull and most linked technique
                                                                    //is techniques for dielectrics if I'm not wrong. So, let's approximate adddelectricalsupport.!
                                                                    //approximate behaviour can be canceled by more rays is hard edges. 
                                                                    //We turn around but it's perfect !
                                                                    //this is not finished !
  
  if( radiance*h*I <= L* addElectricalSupport  )   //As i designed a supercomputer celles architecture
              return  cacheTexture;                                                //I saw that logarithmic functions are also usefull !7  
                                                                    //Then lets add a log pass in the GPU ! So, add a term in the previous inegalities 
                                                                      //The log function can be a derivative for the created texture.
                                                                    //Then, as this is supercomputer cells architecture, we have a cache that is not an approximate solution !
                                                                      //from scratch, Im not sure !

}


//The spin theory deosn t seem to be the largest thing that is usefull to understand and imagine
//previous researchers works. In this case, although I told it spin, we have to forbid using
//laws like p = m*g. As I already used heat mechanics in another project, radiance and irradiance
//could be used here ! Where did I put those last formulas ? In my cell phone and I shared it with
//a freelancer ! This function is also usiefull to prevent using secure graphics methods all the time.
void approximateSpinForIrradianceCachingAndDontUseLawsForIrradianceAndHeat(.....)
{


}







